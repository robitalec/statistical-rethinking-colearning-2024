---
title: "Lecture 15 Notes"
author: "Alec L. Robitaille"
date: "2024-05-02"
---

```{r, include = FALSE}
source('R/packages.R')
```


# Social networks

Social network are patterns of directed exchange. Social networks 
are abstractions, not data. 

Social relationships are latent variables, they cannot be directly
observed but the behaviours that contribute to them can be. 

Relationships are paired, eg. A to B and B to A, and either of these
can motivate behaviours. These relationships don't have to be 
symmetrical, eg. A may perceive their relationship with B as 
stronger than B does. 


## Example: gift giving

- Ha, Hb: household A, B
	- features of households, eg. location, wealth, etc.
- Gab: A gives to B
- Tab: Social tie from A to B
- Tba: Social tie from B to A

```{r}
#| fig.height: 4
#| fig.width: 5
coords <- data.frame(
	name = c('Ha', 'Hb', 'Gab', 'Tab', 'Tba'),
	x =    c(1,       3,     2,     2,     2),
	y =    c(0,       0,  0.25,    -1,     1)
)
dagify(
	Gab ~ Ha + Hb + Tab + Tba,
	Tba ~ Ha + Hb,
	Tab ~ Ha + Hb,
	latent = c('Tab', 'Tba'),
  coords = coords
) |> ggdag_status(seed = 2, layout = 'auto') + theme_dag()
```



# Network permutation

A principled approach to modeling networks requires thinking 
generatively about social relationships. Network permutation 
methods do not have a generative model underpinning their 
approach. They consider some null network and compare if observed
networks differ from the null. See eg. Hart et al 2021. 



## Example: Koster Leckie

Food transfers between households

```{r}
#| fig.height: 4
#| fig.width: 5
coords <- data.frame(
	name = c('Ha', 'Hb', 'Gab', 'Tab', 'Tba'),
	x =    c(1,       3,     2,     2,     2),
	y =    c(0,       0,  0.25,    -1,     1)
)
dagify(
	Gab ~ Ha + Hb + Tab + Tba,
	Tba ~ Ha + Hb,
	Tab ~ Ha + Hb,
	latent = c('Tab', 'Tba'),
  coords = coords
) |> ggdag_status(seed = 2, layout = 'auto') + theme_dag()
```

Approach: There any backdoor paths through household features, but
start with the simplest model first and scaffold your way up
by adding complexity slowly. 


### Generative model without backdoor paths

```{r}
#| fig.height: 4
#| fig.width: 5
coords <- data.frame(
	name = c('Ha', 'Hb', 'Gab', 'Tab', 'Tba'),
	x =    c(1,       3,     2,     2,     2),
	y =    c(0,       0,  0.25,    -1,     1)
)
dagify(
	Gab ~ Tab + Tba,
	Tba ~ Ha + Hb,
	Tab ~ Ha + Hb,
	latent = c('Tab', 'Tba'),
  coords = coords
) |> ggdag_status(seed = 2, layout = 'auto') + theme_dag()
```


```{r}
# Number of households
N <- 25

# Set up dyads
combs <- CJ(left = seq.int(N), right = seq.int(N))
dyads <- combs[left != right]
dyad_id(dyads, 'left', 'right')

# Simulate friendships
dyads[, f := rbern(1, 0.1), by = dyadID]

# Simulate directed ties
# - alpha is the base rate of the ties, where inv_logit(-3) = 0.04743
alpha <- -3
# - probability of the tie if 1 if friends, and base rate if not
dyads[, p_tie := f + (1 - f) * inv_logit(alpha)]
# - tie between left and right
dyads[, y := rbern(.N, prob = p_tie)]

# Gifts
lambda <- log(c(0.5, 2))
gifts <- dyads[, n_gift := rpois(.N, exp(lambda[1 + y]))]
```

The known social relationships are shown here, but other
than in a generative simulation, these relationships 
are latent and can't be truly known - only estimated from
behaviours. 

```{r}
library(igraph)
g <- graph_from_data_frame(dyads[f == 1])
plot(g)
```

### Statistical model without backdoor paths

$$G_{AB} \sim Poisson(\lambda_{AB})$$

$$log(\lambda_{AB}) = \alpha + T_{AB}$$

- Gift giving is a count, modeled using a Poisson
- $\alpha$ is the average rate of gift giving, independent of social ties
- $T_{AB}$ is the tie between A and B

We also included the relationships from the opposite directions

$$G_{BA} \sim Poisson(\lambda_{BA})$$

$$log(\lambda_{BA}) = \alpha + T_{BA}$$

- $T_{BA}$ is the tie between B and A

$$\begin{pmatrix}P \\ B \end{pmatrix} \sim MVNormal \begin{pmatrix} \begin{bmatrix}0 \\ 0\end{bmatrix}, \begin{bmatrix} \sigma^{2}, \rho\sigma^{2} \\ \rho\sigma^{2}, \sigma^{2}\end{bmatrix}\end{pmatrix}$$
$$\rho \sim LKJCorr(2)$$

$$\sigma \sim Exponential(1)$$

$$\alpha \sim Normal(0, 1)$$


- $\rho\sigma^{2}$ is the covariance within dyads (bottom left, top right)
- $\sigma^{2}$ is the variance among ties (top left, bottom right)
- the covariance matrix is symmetric, there is only one standard deviation 
(this is a simpler covariance matrix than the generalized ones from L14)

This is a model with partial pooling for network ties. 

```{r}
library(STRAND)

mat <- as.matrix(dcast(gifts, left ~ right, value.var = 'n_gift')[, -1])
dimnames(mat) <- list(colnames(mat), colnames(mat))
outcome <- list(mat)

dat <- make_strand_data(
	outcome = outcome,
	block_covariates = NULL,
	individual_covariates = NULL,
	dyadic_covariates = NULL,
	outcome_mode = "poisson",
	exposure = NULL
)

m <- fit_social_relations_model(
	data = dat,
	focal_regression = ~ 1,
	target_regression = ~ 1,
	dyad_regression = ~ 1,
	mode = 'vb',
	stan_mcmc_parameters = list(chains = 1, iter_warmup = 500, 
															iter_sampling = 500)
)
```



```{r}
library(bisonR)
??bisonR

gifts[, left := factor(left)]
gifts[, right := factor(right)]
me <- bison_model(
	formula = n_gift ~ dyad(left, right),
	data = gifts,
	model_type = 'count',
	directed = TRUE,
	partial_pooling = TRUE,
	zero_inflated = TRUE,
	priors = get_default_priors('count')
)

bisonR:::get_bison_model_data(
	formula = n_gift ~ dyad(left, right),
	observations = gifts,
	model_type = 'count',
	directed = TRUE
)
